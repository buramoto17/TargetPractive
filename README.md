# TargetPractive
Meggy Final Project Reflection

	I first started thinking of my final project design as an old arcade game. I put myself into this mindset because older games had less pixels than modern ones. I talked to my family about old arcade games that they used to play. The one that I found the most interesting was a game called missile command. This game is where you have to destroy incoming missiles before it reaches one of your cities.
	I decided to modify the game a little bit to fit my programing and meggy’s abilities. I made the whole bottom row of the meggy light up green to indicate cities. Then red dots would come down from the top of the screen and slowly advance towards the cities. The player would have a small platform that could block the dots coming down from the bottom of the screen. 
	When I started to program it, I had to think of how to create the cities at the bottom and how they would disappear when a missile hit it. I decided to us an array to indicate wether they were destroyed or not. I was surprised that this array replaced eight variables that would have taken up many more lines of code. When I went through my draw cities method, I only drew the city if it’s array place was equal to one.
	The hardest part about this game was programming the enemies. I waned to make the enemies so that they appeared at random x coordinates on the screen and came down toward the red dots at a consistent rate. Similar to the cities, I used an array to show if they were destroyed or not. I also used two more arrays to mark the x and y coordinates of an enemy. At the start of the method, I realized that I needed some special lines of code to run only once when the method was called. To solve this problem, I used a variable that would be set to zero at the start and an if statement in the method that would run when the variable was zero. Once the code inside of that if statement executed, I set the variable to one so that the same code did not run again until I set it back to zero. This worked efficiently and effectively.
	Even though I tried my best to get all of the bugs out, there were a few that were still there when I finished it. The main one was that when the player moved the platform and covered a dot from the side, the enemy was not destroyed. I tried to make it so that the dot would try to read the color of it’s current pixel as well as the pixel before it, but it ended up messing with the rest of the working code. Luckily, I had saved an earlier version of the game, so I reverted back to that and tried to improve on it. I think the next thing that I would have tried is to keep the code where the enemy read the pixel that it was on, and switch up the method order so that it drew the enemy first then the platform so that the current pixel would be the platform color.
	If I had more time to work on this project, I would have made the platform a crosshair and the player had to press the a button to “fire” and destroy the enemy. This would get rid of the exploit where the player could just wait above two dots and the red dots could not get to the cities beneath the platform. I learned about this exploit when I was beta testing my game. I could also add sound to my game to make it more interesting and fun for the player. 
	Creating this game showed me how hard it is to debug code if it is not commented. I easily get lost if I can’t understand what a specific piece of code is doing, so comments help a lot to find out where a bug is in the code.
